---
alwaysApply: true
---

# TypeScript Coding Standards

Universal TypeScript coding standards that ensure consistency, maintainability, and type safety across all TypeScript projects.

## Core Principles

### Type Safety First
- Leverage TypeScript's type system for compile-time error prevention
- Use explicit interfaces and types over `any`
- Enable strict TypeScript compiler options
- Handle null/undefined cases explicitly

### Code Organization
- Single Responsibility Principle for files and functions
- Modular design with clear interfaces
- Consistent naming conventions across all code
- Logical file and directory structure

### Performance and Maintainability
- Optimize for readability and maintainability over cleverness
- Use React optimization patterns (memo, useMemo, useCallback) judiciously
- Keep functions and components focused and testable
- Prefer composition over inheritance

## File Size Guidelines

### Code Files
- **TypeScript/JavaScript files (.ts, .tsx, .js, .jsx)**: Under 300 lines
- **Reason**: Easier to understand, test, and maintain
- **Action**: Refactor into smaller modules when exceeded
- **Exception**: Generated files or complex algorithms with clear documentation

### Test Files
- **Test files (.test.ts, .test.tsx, .spec.ts)**: Aim for under 500 lines
- **Reason**: Test files can be longer due to setup, mocks, and multiple scenarios
- **Action**: Group related tests and extract common utilities if exceeded
- **Best practice**: One test file per source file when possible

### Configuration Files
- **Config files**: Keep concise and well-commented
- **Documentation**: Include comments explaining non-obvious configurations
- **Modularity**: Split large configs into logical sections

## Naming Conventions

### Folders and Directories
- **Format**: `kebab-case` or `camelCase` (be consistent within project)
- **Examples**: `user-management/`, `userManagement/`
- **Feature folders**: Group related functionality together
- **Avoid**: Generic names like `utils`, `helpers`, `common`

### Component Files
- **Format**: `PascalCase.tsx` with descriptive, role-based names
- **Page components**: `*Page.tsx` (e.g., `UserProfilePage.tsx`)
- **Panel components**: `*Panel.tsx` (e.g., `SettingsPanel.tsx`)
- **Form components**: `*Form.tsx` (e.g., `LoginForm.tsx`)
- **List components**: `*List.tsx` (e.g., `UserList.tsx`)
- **Item components**: `*Item.tsx` (e.g., `UserListItem.tsx`)
- **Card components**: `*Card.tsx` (e.g., `ProductCard.tsx`)
- **Settings components**: `*Settings.tsx` (e.g., `AccountSettings.tsx`)

### Hooks and Utilities
- **Custom hooks**: `useCamelCase` (e.g., `useAuth.ts`, `useApiData.ts`)
- **Utility files**: `camelCase` (e.g., `apiClient.ts`, `dateUtils.ts`)
- **Constants**: `UPPER_SNAKE_CASE` for values, `camelCase` for files
- **Types**: `PascalCase` for interfaces and types

## TypeScript Best Practices

### Interface and Type Definitions
```typescript
// Explicit interfaces for component props
interface UserCardProps {
  user: User;
  onEdit?: (userId: string) => void;
  showActions?: boolean;
}

// Generic types for reusability
interface ApiResponse<T> {
  data: T;
  status: 'success' | 'error';
  message?: string;
}

// Union types for known values
type Theme = 'light' | 'dark' | 'auto';
```

### Function and Component Structure
```typescript
// Component with explicit props interface
interface ComponentProps {
  title: string;
  data: DataType[];
  onAction?: (id: string) => void;
}

export default function Component({ 
  title, 
  data, 
  onAction 
}: ComponentProps) {
  // Component implementation
  return (
    <div>
      <h1>{title}</h1>
      {/* Component JSX */}
    </div>
  );
}

// Utility function with explicit types
export const processUserData = (
  users: User[], 
  filter: UserFilter
): ProcessedUser[] => {
  return users
    .filter(user => matchesFilter(user, filter))
    .map(user => processUser(user));
};
```

### Error Handling Patterns
```typescript
// Type-safe error handling
type Result<T, E = Error> = 
  | { success: true; data: T }
  | { success: false; error: E };

// Async operations with proper error boundaries
const fetchUserData = async (id: string): Promise<Result<User>> => {
  try {
    const response = await apiClient.get(`/users/${id}`);
    return { success: true, data: response.data };
  } catch (error) {
    return { 
      success: false, 
      error: error instanceof Error ? error : new Error('Unknown error')
    };
  }
};
```

## State Management Patterns

### Local Component State
```typescript
// Typed useState
const [user, setUser] = useState<User | null>(null);
const [loading, setLoading] = useState<boolean>(false);
const [error, setError] = useState<string | null>(null);

// useReducer for complex state
interface State {
  data: User[];
  loading: boolean;
  error: string | null;
}

type Action = 
  | { type: 'FETCH_START' }
  | { type: 'FETCH_SUCCESS'; payload: User[] }
  | { type: 'FETCH_ERROR'; payload: string };

const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case 'FETCH_START':
      return { ...state, loading: true, error: null };
    case 'FETCH_SUCCESS':
      return { ...state, loading: false, data: action.payload };
    case 'FETCH_ERROR':
      return { ...state, loading: false, error: action.payload };
    default:
      return state;
  }
};
```

### Context API Usage
```typescript
// Typed context with proper error handling
interface AuthContextType {
  user: User | null;
  login: (credentials: LoginCredentials) => Promise<void>;
  logout: () => void;
  isLoading: boolean;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const useAuth = (): AuthContextType => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
};
```

## Custom Hooks Pattern

### Purpose and Benefits
- **Extract stateful logic** from components
- **Enhance reusability** across multiple components
- **Improve testability** by isolating business logic
- **Maintain component focus** on rendering and user interaction

### Hook Structure Template
```typescript
// Custom hook with proper typing
export const useApiData = <T>(url: string) => {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<Error | null>(null);

  const refetch = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const result = await response.json();
      setData(result);
    } catch (err) {
      setError(err instanceof Error ? err : new Error('Unknown error'));
    } finally {
      setLoading(false);
    }
  }, [url]);

  useEffect(() => {
    refetch();
  }, [refetch]);

  return { data, loading, error, refetch };
};
```

### Hook Organization
- **Global hooks**: `src/hooks/` - Used across multiple features
- **Feature hooks**: `src/features/[feature]/hooks/` - Feature-specific logic
- **Component hooks**: `src/components/[component]/hooks/` - Component-specific logic

## Import/Export Patterns

### Barrel Exports
```typescript
// src/components/index.ts
export { default as UserCard } from './UserCard';
export { default as UserList } from './UserList';
export { default as UserForm } from './UserForm';

// Usage
import { UserCard, UserList } from '../components';
```

### Path Aliases Configuration
```typescript
// tsconfig.json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"],
      "@/components/*": ["src/components/*"],
      "@/hooks/*": ["src/hooks/*"],
      "@/utils/*": ["src/utils/*"]
    }
  }
}

// Usage
import { useAuth } from '@/hooks/useAuth';
import { UserCard } from '@/components/UserCard';
```

### Export Preferences
- **Named exports** for utilities and hooks
- **Default exports** for React components
- **Type-only imports** when importing only types

```typescript
// Named exports for utilities
export const formatDate = (date: Date): string => { /* */ };
export const validateEmail = (email: string): boolean => { /* */ };

// Type-only imports
import type { User } from '@/types/User';
import type { ComponentProps } from 'react';
```

## Performance Optimization

### React Optimization Patterns
```typescript
// Memoize expensive components
const ExpensiveComponent = React.memo(({ data }: { data: ComplexData }) => {
  return <div>{/* Complex rendering */}</div>;
});

// Memoize expensive calculations
const ProcessedData = ({ rawData }: { rawData: RawData[] }) => {
  const processedData = useMemo(() => {
    return rawData.map(item => expensiveProcessing(item));
  }, [rawData]);

  return <div>{/* Render processed data */}</div>;
};

// Memoize callbacks to prevent unnecessary re-renders
const ParentComponent = () => {
  const [count, setCount] = useState(0);
  
  const handleClick = useCallback((id: string) => {
    // Handle click logic
  }, []); // Dependencies array

  return <ChildComponent onClick={handleClick} />;
};
```

### Bundle Optimization
```typescript
// Dynamic imports for code splitting
const LazyComponent = lazy(() => import('./LazyComponent'));

// Route-based code splitting
const UserPage = lazy(() => import('../pages/UserPage'));

// Conditional imports
const loadAdminFeatures = async () => {
  if (user.role === 'admin') {
    const { AdminPanel } = await import('./AdminPanel');
    return AdminPanel;
  }
  return null;
};
```

## Testing Standards

### Test File Organization
```typescript
// Component.test.tsx - Co-located with component
import { render, screen, fireEvent } from '@testing-library/react';
import { Component } from './Component';

describe('Component', () => {
  const defaultProps = {
    title: 'Test Title',
    onAction: jest.fn()
  };

  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should render with provided title', () => {
    render(<Component {...defaultProps} />);
    expect(screen.getByText('Test Title')).toBeInTheDocument();
  });

  it('should call onAction when button is clicked', () => {
    render(<Component {...defaultProps} />);
    fireEvent.click(screen.getByRole('button'));
    expect(defaultProps.onAction).toHaveBeenCalledTimes(1);
  });
});
```

### Testing Practices
- **Unit tests** for utilities, hooks, and pure functions
- **Integration tests** for component interactions and workflows
- **Mock external dependencies** appropriately
- **Test user behavior** rather than implementation details
- **Use descriptive test names** that explain the expected behavior

## Code Quality Tools

### ESLint Configuration
```json
{
  "extends": [
    "@typescript-eslint/recommended",
    "@typescript-eslint/recommended-requiring-type-checking"
  ],
  "rules": {
    "@typescript-eslint/explicit-function-return-type": "warn",
    "@typescript-eslint/no-unused-vars": "error",
    "@typescript-eslint/prefer-const": "error",
    "@typescript-eslint/no-explicit-any": "error",
    "@typescript-eslint/prefer-nullish-coalescing": "error",
    "@typescript-eslint/prefer-optional-chain": "error"
  }
}
```

### TypeScript Configuration
```json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedIndexedAccess": true,
    "exactOptionalPropertyTypes": true
  }
}
```

## Documentation Requirements

### Component Documentation
```typescript
/**
 * UserCard displays user information in a card format with optional actions
 * 
 * @param user - User object containing name, email, and avatar information
 * @param onEdit - Optional callback function called when edit button is clicked
 * @param showActions - Whether to display action buttons (default: true)
 * @returns JSX element representing the user card
 * 
 * @example
 * ```tsx
 * <UserCard 
 *   user={userData} 
 *   onEdit={(id) => handleEdit(id)}
 *   showActions={true}
 * />
 * ```
 */
interface UserCardProps {
  user: User;
  onEdit?: (userId: string) => void;
  showActions?: boolean;
}
```

### API and Utility Documentation
- **Document all public interfaces** with JSDoc comments
- **Include usage examples** for complex functions
- **Describe parameter types** and return values
- **Note side effects** and requirements
- **Explain complex algorithms** with inline comments

## Forbidden Practices

### Type Safety Violations
- ❌ **Never use `any`** without explicit justification
- ❌ **Avoid type assertions** (`as Type`) unless absolutely necessary
- ❌ **Don't ignore TypeScript errors** with `@ts-ignore`
- ❌ **Never disable strict mode** without team agreement

### Performance Anti-patterns
- ❌ **Don't create objects/functions in render** without memoization
- ❌ **Avoid unnecessary useEffect dependencies**
- ❌ **Don't overuse React.memo** on simple components
- ❌ **Never mutate props or state directly**

### Code Organization Issues
- ❌ **No god components** - Keep components focused and small
- ❌ **Avoid deep prop drilling** - Use context or state management
- ❌ **Don't mix business logic with UI logic**
- ❌ **Never commit commented-out code**

## Success Metrics

### Code Quality
- **Type coverage** - High percentage of typed code
- **Test coverage** - Comprehensive test coverage for critical paths
- **Linting compliance** - Clean ESLint and TypeScript compiler output
- **Performance metrics** - No unnecessary re-renders or memory leaks

### Developer Experience
- **Onboarding speed** - New developers can contribute quickly
- **Debugging efficiency** - Issues are easy to trace and fix
- **Refactoring safety** - Changes can be made confidently
- **Documentation completeness** - All public APIs are documented