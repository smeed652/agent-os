#!/usr/bin/env node

/**
 * Code Quality Validator
 * 
 * Comprehensive code quality validation with intelligent file size analysis,
 * exception handling, and actionable recommendations.
 */

const fs = require('fs');
const path = require('path');

class CodeQualityValidator {
  constructor() {
    this.results = {
      passed: 0,
      failed: 0,
      warnings: 0,
      validations: []
    };
    
    this.fileSizeRules = {
      codeFiles: {
        limit: 300,
        extensions: ['.ts', '.tsx', '.js', '.jsx', '.rb', '.py', '.php', '.java', '.cs'],
        exceptions: [
          'test files',
          'documentation files', 
          'generated files',
          'complex algorithms with comprehensive documentation',
          'configuration files with extensive comments'
        ]
      },
      testFiles: {
        limit: 500,
        extensions: ['.test.ts', '.test.tsx', '.spec.ts', '.spec.js', '_test.rb', '_spec.rb', '.test.py', '.spec.py']
      },
      documentationFiles: {
        limit: null, // No strict limit
        extensions: ['.md', '.txt', '.rst', '.adoc'],
        recommendation: 'Use modular approach for very long documents'
      },
      configFiles: {
        limit: 200,
        extensions: ['.json', '.yaml', '.yml', '.config.js', '.config.ts', '.toml', '.ini'],
        requirement: 'Keep concise and well-commented'
      }
    };
  }

  async validateFile(filePath) {
    if (!fs.existsSync(filePath)) {
      return {
        file: filePath,
        status: 'FAIL',
        validations: [],
        summary: { total: 0, passed: 0, warnings: 0, failed: 0 },
        recommendations: [],
        error: 'File does not exist'
      };
    }

    const content = fs.readFileSync(filePath, 'utf8');
    const validations = [];

    // File size validation
    const sizeValidation = this.validateFileSize(filePath, content);
    validations.push(sizeValidation);

    // Code quality validations (only for code files)
    if (this.isCodeFile(filePath)) {
      validations.push(this.validateFunctionComplexity(content, filePath));
      validations.push(this.validateCodeDuplication(content, filePath));
      validations.push(this.validateErrorHandling(content, filePath));
      validations.push(this.validateNamingConventions(content, filePath));
      validations.push(this.validateCommentQuality(content, filePath));
    }

    // TypeScript specific validations
    if (this.isTypeScriptFile(filePath)) {
      validations.push(this.validateTypeScriptCompliance(content, filePath));
    }

    const overallResult = this.aggregateValidations(validations);
    
    return {
      file: filePath,
      status: overallResult.status,
      validations: validations,
      summary: overallResult.summary,
      recommendations: overallResult.recommendations
    };
  }

  validateFileSize(filePath, content) {
    const lines = content.split('\n').length;
    const fileType = this.getFileType(filePath);
    const rule = this.fileSizeRules[fileType];
    
    if (!rule || !rule.limit) {
      return this.createValidation('File Size', 'PASS', `No size limit for ${fileType}`, {
        lines: lines,
        type: fileType
      });
    }

    if (lines > rule.limit) {
      // Check for valid exceptions
      const exceptions = this.detectExceptions(content, filePath);
      
      if (exceptions.length > 0) {
        return this.createValidation('File Size', 'WARNING', 
          `File has ${lines} lines (exceeds ${rule.limit} limit) but has valid exceptions: ${exceptions.join(', ')}`, {
            lines: lines,
            limit: rule.limit,
            exceptions: exceptions,
            recommendation: 'Monitor file growth and consider refactoring if it continues to grow'
          });
      }
      
      return this.createValidation('File Size', 'FAIL',
        `File has ${lines} lines, exceeds limit of ${rule.limit}`, {
          lines: lines,
          limit: rule.limit,
          recommendation: 'Refactor into smaller, focused modules'
        });
    }

    return this.createValidation('File Size', 'PASS', 
      `File size within limits (${lines}/${rule.limit} lines)`, {
        lines: lines,
        limit: rule.limit
      });
  }

  detectExceptions(content, filePath) {
    const exceptions = [];
    
    // Generated file detection
    if (content.includes('// Generated by') || 
        content.includes('# Generated by') || 
        content.includes('/* Generated by') ||
        content.includes('// This file is auto-generated') ||
        content.includes('# This file is auto-generated')) {
      exceptions.push('generated file');
    }
    
    // Test file detection
    if (this.isTestFile(filePath)) {
      exceptions.push('test file');
    }
    
    // Complex algorithm with comprehensive documentation
    const commentLines = (content.match(/\/\*[\s\S]*?\*\/|\/\/.*$|#.*$|"""[\s\S]*?"""/gm) || []);
    const commentRatio = commentLines.join('').length / content.length;
    
    if (commentRatio > 0.3) {
      exceptions.push('comprehensive documentation');
    }
    
    // Configuration with extensive comments
    if (this.isConfigFile(filePath) && commentRatio > 0.25) {
      exceptions.push('extensively commented configuration');
    }
    
    // Complex algorithm detection (high cyclomatic complexity with good documentation)
    const functionCount = (content.match(/function\s+\w+|const\s+\w+\s*=\s*\(|class\s+\w+/g) || []).length;
    const avgFunctionSize = content.split('\n').length / Math.max(functionCount, 1);
    
    if (avgFunctionSize > 50 && commentRatio > 0.25) {
      exceptions.push('complex algorithms with documentation');
    }
    
    return exceptions;
  }

  validateFunctionComplexity(content, filePath) {
    const functions = this.extractFunctions(content, filePath);
    const complexFunctions = [];
    
    functions.forEach(func => {
      const complexity = this.calculateCyclomaticComplexity(func.body);
      if (complexity > 10) {
        complexFunctions.push({
          name: func.name,
          complexity: complexity,
          line: func.line
        });
      }
    });

    if (complexFunctions.length > 0) {
      return this.createValidation('Function Complexity', 'FAIL',
        `${complexFunctions.length} functions exceed complexity limit (>10)`, {
          complexFunctions: complexFunctions,
          recommendation: 'Break down complex functions into smaller, focused functions'
        });
    }

    return this.createValidation('Function Complexity', 'PASS',
      'All functions within complexity limits (≤10)', {
        functionCount: functions.length
      });
  }

  validateCodeDuplication(content, filePath) {
    const duplicatedBlocks = this.findDuplicatedCode(content);
    
    if (duplicatedBlocks.length > 0) {
      return this.createValidation('Code Duplication', 'WARNING',
        `Found ${duplicatedBlocks.length} potential code duplication blocks`, {
          duplicatedBlocks: duplicatedBlocks,
          recommendation: 'Extract common code into reusable functions or modules'
        });
    }

    return this.createValidation('Code Duplication', 'PASS',
      'No significant code duplication detected');
  }

  validateErrorHandling(content, filePath) {
    const hasErrorHandling = this.checkErrorHandling(content, filePath);
    
    if (!hasErrorHandling.adequate) {
      return this.createValidation('Error Handling', 'WARNING',
        'Insufficient error handling detected', {
          issues: hasErrorHandling.issues,
          recommendation: 'Add proper try-catch blocks and error handling for external operations'
        });
    }

    return this.createValidation('Error Handling', 'PASS',
      'Adequate error handling present');
  }

  validateNamingConventions(content, filePath) {
    const namingIssues = this.checkNamingConventions(content, filePath);
    
    if (namingIssues.length > 0) {
      return this.createValidation('Naming Conventions', 'WARNING',
        `Found ${namingIssues.length} naming convention issues`, {
          issues: namingIssues,
          recommendation: 'Use descriptive, consistent naming following project conventions'
        });
    }

    return this.createValidation('Naming Conventions', 'PASS',
      'Naming conventions followed');
  }

  validateCommentQuality(content, filePath) {
    const commentAnalysis = this.analyzeComments(content);
    
    if (commentAnalysis.quality < 0.6) {
      return this.createValidation('Comment Quality', 'WARNING',
        'Comment quality could be improved', {
          score: commentAnalysis.quality,
          issues: commentAnalysis.issues,
          recommendation: 'Add meaningful comments explaining "why" rather than "what"'
        });
    }

    return this.createValidation('Comment Quality', 'PASS',
      `Good comment quality (score: ${commentAnalysis.quality.toFixed(2)})`);
  }

  validateTypeScriptCompliance(content, filePath) {
    const tsIssues = this.checkTypeScriptCompliance(content);
    
    if (tsIssues.length > 0) {
      return this.createValidation('TypeScript Compliance', 'FAIL',
        `Found ${tsIssues.length} TypeScript compliance issues`, {
          issues: tsIssues,
          recommendation: 'Fix TypeScript type errors and add proper type annotations'
        });
    }

    return this.createValidation('TypeScript Compliance', 'PASS',
      'TypeScript compliance maintained');
  }

  // Utility methods
  getFileType(filePath) {
    const ext = path.extname(filePath).toLowerCase();
    
    // Test files take priority over other classifications
    if (this.isTestFile(filePath)) return 'testFiles';
    if (this.fileSizeRules.documentationFiles.extensions.includes(ext)) return 'documentationFiles';
    if (this.fileSizeRules.configFiles.extensions.includes(ext)) return 'configFiles';
    if (this.fileSizeRules.codeFiles.extensions.includes(ext)) return 'codeFiles';
    
    return 'unknown';
  }

  isCodeFile(filePath) {
    const ext = path.extname(filePath).toLowerCase();
    return this.fileSizeRules.codeFiles.extensions.includes(ext) && !this.isTestFile(filePath);
  }

  isTestFile(filePath) {
    const fileName = path.basename(filePath).toLowerCase();
    const dirName = path.dirname(filePath).toLowerCase();
    
    // Standard test file patterns
    if (fileName.includes('.test.') || fileName.includes('.spec.') || 
        fileName.includes('_test.') || fileName.includes('_spec.')) {
      return true;
    }
    
    // Files in test directories (be more specific to avoid false positives)
    // Only consider immediate parent directory or common test directory names
    const dirParts = dirName.split(path.sep);
    const immediateParent = dirParts[dirParts.length - 1];
    const testDirPatterns = ['test', 'tests', 'spec', 'specs', '__tests__', '__test__'];
    
    // Check if the immediate parent directory is a test directory
    if (testDirPatterns.includes(immediateParent)) {
      return true;
    }
    
    // Check for common test directory patterns in the full path
    const hasTestDir = dirParts.some(part => 
      part === 'test' || part === 'tests' || part === '__tests__' || 
      part === 'spec' || part === 'specs'
    );
    
    // But exclude framework/tooling directories that might contain "test" 
    const isFrameworkDir = dirParts.some(part => 
      part === 'node_modules' || part === '.agent-os' || part === 'scripts' || 
      part === 'validators' || part === 'temp-projects'
    );
    
    if (hasTestDir && !isFrameworkDir) {
      return true;
    }
    
    // Files with "test" in the name (like test-validators.js)
    if (fileName.startsWith('test-') || fileName.endsWith('-test.js') || fileName.endsWith('-test.ts')) {
      return true;
    }
    
    return false;
  }

  isConfigFile(filePath) {
    const ext = path.extname(filePath).toLowerCase();
    return this.fileSizeRules.configFiles.extensions.includes(ext);
  }

  isTypeScriptFile(filePath) {
    const ext = path.extname(filePath).toLowerCase();
    return ['.ts', '.tsx'].includes(ext);
  }

  extractFunctions(content, filePath) {
    // Simple function extraction - can be enhanced based on language
    const functions = [];
    const lines = content.split('\n');
    
    // JavaScript/TypeScript function patterns
    const functionPatterns = [
      /function\s+(\w+)/,
      /const\s+(\w+)\s*=\s*\(/,
      /(\w+)\s*:\s*\(/,
      /(\w+)\s*\(/
    ];

    lines.forEach((line, index) => {
      functionPatterns.forEach(pattern => {
        const match = line.match(pattern);
        if (match) {
          functions.push({
            name: match[1],
            line: index + 1,
            body: this.extractFunctionBody(lines, index)
          });
        }
      });
    });

    return functions;
  }

  extractFunctionBody(lines, startIndex) {
    // Simple body extraction - looks for opening/closing braces
    let braceCount = 0;
    let body = [];
    let started = false;

    for (let i = startIndex; i < lines.length; i++) {
      const line = lines[i];
      
      if (line.includes('{')) {
        braceCount += (line.match(/{/g) || []).length;
        started = true;
      }
      
      if (started) {
        body.push(line);
      }
      
      if (line.includes('}')) {
        braceCount -= (line.match(/}/g) || []).length;
        if (braceCount <= 0 && started) break;
      }
    }

    return body.join('\n');
  }

  calculateCyclomaticComplexity(functionBody) {
    // Basic cyclomatic complexity calculation
    const complexityKeywords = [
      'if', 'else', 'while', 'for', 'case', 'catch', 'and', 'or', '&&', '||', '?'
    ];
    
    let complexity = 1; // Base complexity
    
    complexityKeywords.forEach(keyword => {
      // Escape special regex characters and handle operators
      const escapedKeyword = keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      const pattern = keyword.length === 1 ? escapedKeyword : `\\b${escapedKeyword}\\b`;
      const matches = functionBody.match(new RegExp(pattern, 'g'));
      if (matches) complexity += matches.length;
    });

    return complexity;
  }

  findDuplicatedCode(content) {
    // Simple duplication detection - looks for repeated blocks of 3+ lines
    const lines = content.split('\n').map(line => line.trim()).filter(line => line.length > 0);
    const duplicates = [];
    
    for (let i = 0; i < lines.length - 2; i++) {
      const block = lines.slice(i, i + 3).join('\n');
      if (block.length < 50) continue; // Skip very short blocks
      
      for (let j = i + 3; j < lines.length - 2; j++) {
        const compareBlock = lines.slice(j, j + 3).join('\n');
        if (block === compareBlock) {
          duplicates.push({
            block: block,
            locations: [`lines ${i + 1}-${i + 3}`, `lines ${j + 1}-${j + 3}`]
          });
        }
      }
    }

    return duplicates;
  }

  checkErrorHandling(content, filePath) {
    const ext = path.extname(filePath).toLowerCase();
    let patterns = [];
    
    if (['.js', '.ts', '.jsx', '.tsx'].includes(ext)) {
      patterns = ['try', 'catch', '.catch(', 'throw'];
    } else if (ext === '.rb') {
      patterns = ['begin', 'rescue', 'raise'];
    } else if (ext === '.py') {
      patterns = ['try:', 'except:', 'raise'];
    }

    const hasAsyncOperations = content.includes('await') || content.includes('fetch') || 
                              content.includes('axios') || content.includes('http');
    const hasErrorHandling = patterns.some(pattern => content.includes(pattern));

    return {
      adequate: !hasAsyncOperations || hasErrorHandling,
      issues: hasAsyncOperations && !hasErrorHandling ? ['Async operations without error handling'] : []
    };
  }

  checkNamingConventions(content, filePath) {
    const issues = [];
    
    // Check for single letter variables (except for loops)
    const singleLetterVars = content.match(/\b[a-z]\s*=/g);
    if (singleLetterVars && singleLetterVars.length > 2) {
      issues.push('Multiple single-letter variable names detected');
    }

    // Check for unclear function names
    const unclearNames = content.match(/function\s+(fn|func|temp|data|item)\b/g);
    if (unclearNames) {
      issues.push('Unclear function names detected');
    }

    return issues;
  }

  analyzeComments(content) {
    const comments = content.match(/\/\*[\s\S]*?\*\/|\/\/.*$/gm) || [];
    const totalComments = comments.length;
    
    if (totalComments === 0) {
      return { quality: 0.3, issues: ['No comments found'] };
    }

    let qualityScore = 0.5; // Base score
    
    // Check for meaningful comments (not just "// TODO" or "// Fix this")
    const meaningfulComments = comments.filter(comment => 
      !comment.match(/todo|fix|hack|temp/i) && comment.length > 20
    );
    
    qualityScore += (meaningfulComments.length / totalComments) * 0.3;
    
    // Check for JSDoc style comments
    const jsDocComments = comments.filter(comment => comment.includes('/**'));
    qualityScore += (jsDocComments.length / totalComments) * 0.2;

    return {
      quality: Math.min(qualityScore, 1.0),
      issues: qualityScore < 0.6 ? ['Comments could be more descriptive'] : []
    };
  }

  checkTypeScriptCompliance(content) {
    const issues = [];
    
    // Check for 'any' types
    if (content.includes(': any')) {
      issues.push('Usage of "any" type detected');
    }

    // Check for missing return types on functions
    const functionsWithoutReturnTypes = content.match(/function\s+\w+\([^)]*\)\s*{/g);
    if (functionsWithoutReturnTypes) {
      issues.push('Functions without explicit return types');
    }

    return issues;
  }

  createValidation(name, status, message, details = {}) {
    return {
      name: name,
      status: status,
      message: message,
      details: details
    };
  }

  aggregateValidations(validations) {
    const failed = validations.filter(v => v.status === 'FAIL').length;
    const warnings = validations.filter(v => v.status === 'WARNING').length;
    const passed = validations.filter(v => v.status === 'PASS').length;

    const overallStatus = failed > 0 ? 'FAIL' : warnings > 0 ? 'WARNING' : 'PASS';
    
    const recommendations = validations
      .filter(v => v.details && v.details.recommendation)
      .map(v => v.details.recommendation);

    return {
      status: overallStatus,
      summary: {
        total: validations.length,
        passed: passed,
        warnings: warnings,
        failed: failed
      },
      recommendations: recommendations
    };
  }

  async validateDirectory(dirPath) {
    const results = [];
    
    const files = this.getAllFiles(dirPath);
    
    for (const file of files) {
      if (this.shouldValidateFile(file)) {
        const result = await this.validateFile(file);
        results.push(result);
      }
    }

    return results;
  }

  getAllFiles(dirPath, files = []) {
    if (!fs.existsSync(dirPath)) return files;
    
    const items = fs.readdirSync(dirPath);
    
    items.forEach(item => {
      const fullPath = path.join(dirPath, item);
      const stat = fs.statSync(fullPath);
      
      if (stat.isDirectory() && !this.shouldSkipDirectory(item)) {
        this.getAllFiles(fullPath, files);
      } else if (stat.isFile()) {
        files.push(fullPath);
      }
    });

    return files;
  }

  shouldSkipDirectory(dirName) {
    const skipDirs = ['node_modules', '.git', 'dist', 'build', '.next', 'coverage'];
    return skipDirs.includes(dirName);
  }

  shouldValidateFile(filePath) {
    const ext = path.extname(filePath).toLowerCase();
    const allExtensions = [
      ...this.fileSizeRules.codeFiles.extensions,
      ...this.fileSizeRules.testFiles.extensions,
      ...this.fileSizeRules.documentationFiles.extensions,
      ...this.fileSizeRules.configFiles.extensions
    ];
    
    return allExtensions.includes(ext);
  }

  displayResults(results) {
    console.log('\n🔍 Code Quality Validation Results');
    console.log('==================================\n');

    results.forEach(result => {
      const statusIcon = result.status === 'PASS' ? '✅' : 
        result.status === 'WARNING' ? '⚠️' : '❌';
      
      console.log(`${statusIcon} ${path.basename(result.file)} (${result.status})`);
      
      if (result.validations.length > 0) {
        result.validations.forEach(validation => {
          const icon = validation.status === 'PASS' ? '  ✓' : 
            validation.status === 'WARNING' ? '  ⚠' : '  ✗';
          console.log(`${icon} ${validation.name}: ${validation.message}`);
        });
      }
      
      if (result.recommendations.length > 0) {
        console.log('  💡 Recommendations:');
        result.recommendations.forEach(rec => {
          console.log(`     - ${rec}`);
        });
      }
      
      console.log('');
    });

    // Summary
    const totalFiles = results.length;
    const passedFiles = results.filter(r => r.status === 'PASS').length;
    const warningFiles = results.filter(r => r.status === 'WARNING').length;
    const failedFiles = results.filter(r => r.status === 'FAIL').length;

    console.log('📊 Summary');
    console.log('----------');
    console.log(`Total Files: ${totalFiles}`);
    console.log(`✅ Passed: ${passedFiles}`);
    console.log(`⚠️ Warnings: ${warningFiles}`);
    console.log(`❌ Failed: ${failedFiles}`);
    console.log(`Success Rate: ${Math.round((passedFiles / totalFiles) * 100)}%\n`);
  }
}

// CLI usage
if (require.main === module) {
  const validator = new CodeQualityValidator();
  const target = process.argv[2] || '.';

  (async () => {
    try {
      let results;
      
      if (fs.statSync(target).isFile()) {
        const result = await validator.validateFile(target);
        results = [result];
      } else {
        results = await validator.validateDirectory(target);
      }
      
      validator.displayResults(results);
      
      const hasFailures = results.some(r => r.status === 'FAIL');
      process.exit(hasFailures ? 1 : 0);
      
    } catch (error) {
      console.error('❌ Validation failed:', error.message);
      process.exit(1);
    }
  })();
}

module.exports = CodeQualityValidator;
